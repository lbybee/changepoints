prep_model = function(n, p){#
#
    X = matrix(runif(n * p, -10, 10), ncol=p)#
    beta = runif(p)#
    Y = X %*% beta#
    residuals = Y - fitted(lm(Y ~ X))#
    sigma2_hat = sum(residuals^2) / (n - p - 1)#
    return(sigma2_hat)#
}#
#
scheffe_band = function(n, p, alpha, sigma2_hat) {#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfacS = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    QFB = qf(alpha, p+1, n-p-1)#
    sfacB = sqrt(sigma2_hat) * sqrt(QFB)#
#
    return(c(sfacS, sfacB))#
}#
scheffe_res = c()#
bon_res = c()#
#
n = 100#
p = 2 #
#
sigma2_hat = prep_model(n, p) #
#
for(i in 1:500){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}
ggplot() + geom_line(aes(x=1:500, y= bon_res)) + geom_line(aes(x=1:500, y=scheffe_res))
library(ggplot2)#
#
prep_model = function(n, p){#
#
    X = matrix(runif(n * p, -10, 10), ncol=p)#
    beta = runif(p)#
    Y = X %*% beta#
    residuals = Y - fitted(lm(Y ~ X))#
    sigma2_hat = sum(residuals^2) / (n - p - 1)#
    return(sigma2_hat)#
}#
#
scheffe_band = function(n, p, alpha, sigma2_hat) {#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfacS = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    QFB = qf(alpha, p+1, n-p-1)#
    sfacB = sqrt(sigma2_hat) * sqrt(QFB)#
#
    return(c(sfacS, sfacB))#
}#
scheffe_res = c()#
bon_res = c()#
#
n = 100#
p = 2 #
iter = 1000#
sigma2_hat = prep_model(n, p) #
#
for(i in 1:iter){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}#
#
ggplot() + geom_line(aes(x=1:iter, y=bon_res)) + geom_line(aes(x=1:iter, y=scheffe_res))
library(ggplot2)#
#
prep_model = function(n, p){#
#
    X = matrix(runif(n * p, -10, 10), ncol=p)#
    beta = runif(p)#
    Y = X %*% beta#
    residuals = Y - fitted(lm(Y ~ X))#
    sigma2_hat = sum(residuals^2) / (n - p - 1)#
    return(sigma2_hat)#
}#
#
scheffe_band = function(n, p, alpha, sigma2_hat) {#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfacS = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    QFB = qf(alpha, p+1, n-p-1)#
    sfacB = sqrt(sigma2_hat) * sqrt((p + 1) * QFB)#
#
    return(c(sfacS, sfacB))#
}#
scheffe_res = c()#
bon_res = c()#
#
n = 100#
p = 2 #
iter = 1000#
sigma2_hat = prep_model(n, p) #
#
for(i in 1:iter){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}#
#
ggplot() + geom_line(aes(x=1:iter, y=bon_res)) + geom_line(aes(x=1:iter, y=scheffe_res))
library(ggplot2)#
#
prep_model = function(n, p){#
#
    X = matrix(runif(n * p, -10, 10), ncol=p)#
    beta = runif(p)#
    Y = X %*% beta#
    residuals = Y - fitted(lm(Y ~ X))#
    sigma2_hat = sum(residuals^2) / (n - p - 1)#
    return(sigma2_hat)#
}#
#
scheffe_band = function(n, p, alpha, sigma2_hat) {#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfacS = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    QFB = qf(alpha, p+1, n-p-1)#
    sfacB = sqrt(sigma2_hat) * sqrt((p + 1) * QFB)#
#
    return(c(sfacS, sfacB))#
}#
scheffe_res = c()#
bon_res = c()#
#
n = 100#
p = 3 #
iter = 200#
sigma2_hat = prep_model(n, p) #
#
for(i in 1:iter){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}#
#
ggplot() + geom_line(aes(x=1:iter, y=bon_res)) + geom_line(aes(x=1:iter, y=scheffe_res))
library(ggplot2)#
#
prep_model = function(n, p){#
#
    X = matrix(runif(n * p, -10, 10), ncol=p)#
    beta = runif(p)#
    Y = X %*% beta#
    residuals = Y - fitted(lm(Y ~ X))#
    sigma2_hat = sum(residuals^2) / (n - p - 1)#
    return(sigma2_hat)#
}#
#
scheffe_band = function(n, p, alpha, sigma2_hat) {#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfacS = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    QFB = qf(alpha, p+1, n-p-1)#
    sfacB = sqrt(sigma2_hat) * sqrt((p + 1) * QFB)#
#
    return(c(sfacS, sfacB))#
}#
scheffe_res = c()#
bon_res = c()#
#
n = 100#
p = 5 #
iter = 100#
sigma2_hat = prep_model(n, p) #
#
for(i in 1:iter){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}#
#
ggplot() + geom_line(aes(x=1:iter, y=bon_res)) + geom_line(aes(x=1:iter, y=scheffe_res)) + xlab("k") + ylab("Multiplier")#
ggsave("scheffe_v_bon.jpg")
library(ggplot2)#
#
prep_model = function(n, p){#
#
    X = matrix(runif(n * p, -10, 10), ncol=p)#
    beta = runif(p)#
    Y = X %*% beta#
    residuals = Y - fitted(lm(Y ~ X))#
    sigma2_hat = sum(residuals^2) / (n - p - 1)#
    return(sigma2_hat)#
}#
#
scheffe_band = function(n, p, alpha, sigma2_hat) {#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfacS = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    QFB = qf(alpha, p+1, n-p-1)#
    sfacB = sqrt(sigma2_hat) * sqrt((p + 1) * QFB)#
#
    return(c(sfacS, sfacB))#
}#
scheffe_res = c()#
bon_res = c()#
#
n = 100#
p = 5 #
iter = 100#
sigma2_hat = prep_model(n, p) #
#
for(i in 1:iter){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}#
#
ggplot() + geom_line(aes(x=1:iter, y=bon_res), color="red") + geom_line(aes(x=1:iter, y=scheffe_res), color="blue") + xlab("k") + ylab("Multiplier")#
ggsave("scheffe_v_bon.jpg")
library(ggplot2)#
#
prep_model = function(n, p){#
#
    X = matrix(runif(n * p, -10, 10), ncol=p)#
    beta = runif(p)#
    Y = X %*% beta#
    residuals = Y - fitted(lm(Y ~ X))#
    sigma2_hat = sum(residuals^2) / (n - p - 1)#
    return(sigma2_hat)#
}#
#
scheffe_band = function(n, p, alpha, sigma2_hat) {#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfacS = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    QFB = qf(alpha, p+1, n-p-1)#
    sfacB = sqrt(sigma2_hat) * sqrt((p + 1) * QFB)#
#
    return(c(sfacS, sfacB))#
}#
scheffe_res = c()#
bon_res = c()#
#
n = 100#
p = 5 #
iter = 50 #
sigma2_hat = prep_model(n, p) #
#
for(i in 1:iter){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}#
#
ggplot() + geom_line(aes(x=1:iter, y=bon_res), color="red") + geom_line(aes(x=1:iter, y=scheffe_res), color="blue") + xlab("k") + ylab("Multiplier")#
ggsave("scheffe_v_bon.jpg")
library(ggplot2)#
#
prep_model = function(n, p){#
#
    X = matrix(runif(n * p, -10, 10), ncol=p)#
    beta = runif(p)#
    Y = X %*% beta#
    residuals = Y - fitted(lm(Y ~ X))#
    sigma2_hat = sum(residuals^2) / (n - p - 1)#
    return(sigma2_hat)#
}#
#
scheffe_band = function(n, p, alpha, sigma2_hat) {#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfacS = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    QFB = qf(alpha, p+1, n-p-1)#
    sfacB = sqrt(sigma2_hat) * sqrt((p + 1) * QFB)#
#
    return(c(sfacS, sfacB))#
}#
scheffe_res = c()#
bon_res = c()#
#
n = 50#
p = 5 #
iter = 50 #
sigma2_hat = prep_model(n, p) #
#
for(i in 1:iter){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}#
#
ggplot() + geom_line(aes(x=1:iter, y=bon_res), color="red") + geom_line(aes(x=1:iter, y=scheffe_res), color="blue") + xlab("k") + ylab("Multiplier")#
ggsave("scheffe_v_bon_short.jpg")#
#
scheffe_res = c()#
bon_res = c()#
#
n = 10000#
p = 5 #
iter = 50 #
sigma2_hat = prep_model(n, p) #
#
for(i in 1:iter){#
    res = scheffe_band(n, p, (1 - (1 - 0.05) /i), sigma2_hat)#
    scheffe_res[i] = res[1]#
    bon_res[i] = res[2]#
}#
#
ggplot() + geom_line(aes(x=1:iter, y=bon_res), color="red") + geom_line(aes(x=1:iter, y=scheffe_res), color="blue") + xlab("k") + ylab("Multiplier")#
ggsave("scheffe_v_bon_long.jpg")
library(ggplot2)#
library(reshape)#
scheffe_band = function(Y, X) {#
#
    n = length(Y)#
    p = dim(X)[2] - 1#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # Factorize the design matrix and get some other needed things.#
    qq = qr(X)#
    Q = qr.Q(qq)#
    R = qr.R(qq)#
    XtX = t(R) %*% R#
    XtXi = solve(XtX)#
#
    # Fit the linear model.#
    beta_hat = solve(R, t(Q) %*% Y)#
#
    # Fitted values, residuals, and estimated error variance.#
    Yhat = X %*% beta_hat#
    resid = Y - Q %*% (t(Q) %*% Y)#
    sigma2_hat = sum(resid^2) / (n - p - 1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfac = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    # The Scheffe confidence band (lower band is in column 1, upper band#
    # is in column 2).#
    S = array(0, c(n,2))#
#
    # Get the band coordinates for each case.#
    for (i in 1:n) {#
        V = X[i,] %*% XtXi %*% X[i,]#
        S[i,1] = Yhat[i] - sfac*sqrt(V)#
        S[i,2] = Yhat[i] + sfac*sqrt(V)#
    }#
#
    return(S)#
}#
t_sample = seq(5, 1000, 5) #
nrep = 50#
# first we test different sample sizes#
n_sample = c(10, 100, 1000)#
n_fit = matrix(0, length(n_sample), length(t_sample))#
#
for(i in 1:length(n_sample)){#
    for(j in 1:length(t_sample)){#
        n = n_sample[i]#
        t = t_sample[j]#
        slopes = runif(2)#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n)#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        n_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
# next we test different beta values#
beta_sample = c(0.1, 1, 10) #
beta_fit = matrix(0, length(beta_sample), length(t_sample))#
#
n = 100#
#
for(i in 1:length(beta_sample)){#
    for(j in 1:length(t_sample)){#
        t = t_sample[j]#
        slopes = c(1, beta_sample[i])#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n)#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        beta_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
# next we test different sigma^2 values#
sigma2_sample = c(0.1, 1, 10, 100) #
sigma2_fit = matrix(0, length(sigma2_sample), length(t_sample))#
#
n = 100#
#
for(i in 1:length(sigma2_sample)){#
    for(j in 1:length(t_sample)){#
        t = t_sample[j]#
        slopes = runif(2)#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n, sd=sqrt(sigma2_sample[i]))#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        sigma2_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
#
df = data.frame(n_fit)#
mlt = melt(df)#
ggplot() + geom_line(aes(x=t_sample, y=value))
library(ggplot2)#
library(reshape)#
scheffe_band = function(Y, X) {#
#
    n = length(Y)#
    p = dim(X)[2] - 1#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # Factorize the design matrix and get some other needed things.#
    qq = qr(X)#
    Q = qr.Q(qq)#
    R = qr.R(qq)#
    XtX = t(R) %*% R#
    XtXi = solve(XtX)#
#
    # Fit the linear model.#
    beta_hat = solve(R, t(Q) %*% Y)#
#
    # Fitted values, residuals, and estimated error variance.#
    Yhat = X %*% beta_hat#
    resid = Y - Q %*% (t(Q) %*% Y)#
    sigma2_hat = sum(resid^2) / (n - p - 1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfac = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    # The Scheffe confidence band (lower band is in column 1, upper band#
    # is in column 2).#
    S = array(0, c(n,2))#
#
    # Get the band coordinates for each case.#
    for (i in 1:n) {#
        V = X[i,] %*% XtXi %*% X[i,]#
        S[i,1] = Yhat[i] - sfac*sqrt(V)#
        S[i,2] = Yhat[i] + sfac*sqrt(V)#
    }#
#
    return(S)#
}#
t_sample = seq(5, 500, 5) #
nrep = 50#
# first we test different sample sizes#
n_sample = c(10, 100, 1000)#
n_fit = matrix(0, length(n_sample), length(t_sample))#
#
for(i in 1:length(n_sample)){#
    for(j in 1:length(t_sample)){#
        n = n_sample[i]#
        t = t_sample[j]#
        slopes = runif(2)#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n)#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        n_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
# next we test different beta values#
beta_sample = c(0.1, 1, 10) #
beta_fit = matrix(0, length(beta_sample), length(t_sample))#
#
n = 100#
#
for(i in 1:length(beta_sample)){#
    for(j in 1:length(t_sample)){#
        t = t_sample[j]#
        slopes = c(1, beta_sample[i])#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n)#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        beta_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
# next we test different sigma^2 values#
sigma2_sample = c(0.1, 1, 10, 100) #
sigma2_fit = matrix(0, length(sigma2_sample), length(t_sample))#
#
n = 100#
#
for(i in 1:length(sigma2_sample)){#
    for(j in 1:length(t_sample)){#
        t = t_sample[j]#
        slopes = runif(2)#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n, sd=sqrt(sigma2_sample[i]))#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        sigma2_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
#
df = data.frame(n_fit)#
mlt = melt(df)#
ggplot() + geom_line(aes(x=t_sample, y=value))
df
install.packages("reshape")
install.packages("reshape2")
library(ggplot2)#
library(reshape)#
scheffe_band = function(Y, X) {#
#
    n = length(Y)#
    p = dim(X)[2] - 1#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # Factorize the design matrix and get some other needed things.#
    qq = qr(X)#
    Q = qr.Q(qq)#
    R = qr.R(qq)#
    XtX = t(R) %*% R#
    XtXi = solve(XtX)#
#
    # Fit the linear model.#
    beta_hat = solve(R, t(Q) %*% Y)#
#
    # Fitted values, residuals, and estimated error variance.#
    Yhat = X %*% beta_hat#
    resid = Y - Q %*% (t(Q) %*% Y)#
    sigma2_hat = sum(resid^2) / (n - p - 1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfac = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    # The Scheffe confidence band (lower band is in column 1, upper band#
    # is in column 2).#
    S = array(0, c(n,2))#
#
    # Get the band coordinates for each case.#
    for (i in 1:n) {#
        V = X[i,] %*% XtXi %*% X[i,]#
        S[i,1] = Yhat[i] - sfac*sqrt(V)#
        S[i,2] = Yhat[i] + sfac*sqrt(V)#
    }#
#
    return(S)#
}#
t_sample = seq(5, 500, 5) #
nrep = 50#
# first we test different sample sizes#
n_sample = c(10, 100, 1000)#
n_fit = matrix(0, length(n_sample), length(t_sample))#
#
for(i in 1:length(n_sample)){#
    for(j in 1:length(t_sample)){#
        n = n_sample[i]#
        t = t_sample[j]#
        slopes = runif(2)#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n)#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        n_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
# next we test different beta values#
beta_sample = c(0.1, 1, 10) #
beta_fit = matrix(0, length(beta_sample), length(t_sample))#
#
n = 100#
#
for(i in 1:length(beta_sample)){#
    for(j in 1:length(t_sample)){#
        t = t_sample[j]#
        slopes = c(1, beta_sample[i])#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n)#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        beta_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
# next we test different sigma^2 values#
sigma2_sample = c(0.1, 1, 10) #
sigma2_fit = matrix(0, length(sigma2_sample), length(t_sample))#
#
n = 100#
#
for(i in 1:length(sigma2_sample)){#
    for(j in 1:length(t_sample)){#
        t = t_sample[j]#
        slopes = runif(2)#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n, sd=sqrt(sigma2_sample[i]))#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        sigma2_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
#
ggplot() + geom_line(aes(x=t_sample, y=n_fit[1,]), color="red") + geom_line(aes(x=t_sample, y=n_fit[2,]), color="blue") + geom_line(aes(x=t_sample, y=n_fit[3,]), color="green") + xlab("t") + ylab("Missing Prob")#
ggsave("sample_size_2.jpg")#
#
ggplot() + geom_line(aes(x=t_sample, y=beta_fit[1,]), color="red") + geom_line(aes(x=t_sample, y=beta_fit[2,]), color="blue") + geom_line(aes(x=t_sample, y=beta_fit[3,]), color="green") + xlab("t") + ylab("Missing Prob")#
ggsave("beta_2.jpg")#
#
ggplot() + geom_line(aes(x=t_sample, y=sigma2_fit[1,]), color="red") + geom_line(aes(x=t_sample, y=sigma2_fit[2,]), color="blue") + geom_line(aes(x=t_sample, y=sigma2_fit[3,]), color="green") + xlab("t") + ylab("Missing Prob")#
ggsave("sigma2_2.jpg")
library(ggplot2)#
scheffe_band = function(Y, X) {#
#
    n = length(Y)#
    p = dim(X)[2] - 1#
#
    # The F-quantile in the Scheffe formula.#
    QF = qf(0.95, p+1, n-p-1)#
#
    # Factorize the design matrix and get some other needed things.#
    qq = qr(X)#
    Q = qr.Q(qq)#
    R = qr.R(qq)#
    XtX = t(R) %*% R#
    XtXi = solve(XtX)#
#
    # Fit the linear model.#
    beta_hat = solve(R, t(Q) %*% Y)#
#
    # Fitted values, residuals, and estimated error variance.#
    Yhat = X %*% beta_hat#
    resid = Y - Q %*% (t(Q) %*% Y)#
    sigma2_hat = sum(resid^2) / (n - p - 1)#
#
    # The factors in the margin of error other than sqrt(V).#
    sfac = sqrt(sigma2_hat) * sqrt((p+1)*QF)#
#
    # The Scheffe confidence band (lower band is in column 1, upper band#
    # is in column 2).#
    S = array(0, c(n,2))#
#
    # Get the band coordinates for each case.#
    for (i in 1:n) {#
        V = X[i,] %*% XtXi %*% X[i,]#
        S[i,1] = Yhat[i] - sfac*sqrt(V)#
        S[i,2] = Yhat[i] + sfac*sqrt(V)#
    }#
#
    return(S)#
}#
t_sample = seq(5, 500, 5) #
nrep = 50#
# first we test different sample sizes#
n_sample = c(10, 100, 1000)#
n_fit = matrix(0, length(n_sample), length(t_sample))#
#
for(i in 1:length(n_sample)){#
    for(j in 1:length(t_sample)){#
        n = n_sample[i]#
        t = t_sample[j]#
        slopes = runif(2)#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n)#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        n_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
# next we test different beta values#
beta_sample = c(0.1, 1, 10) #
beta_fit = matrix(0, length(beta_sample), length(t_sample))#
#
n = 100#
#
for(i in 1:length(beta_sample)){#
    for(j in 1:length(t_sample)){#
        t = t_sample[j]#
        slopes = c(1, beta_sample[i])#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n)#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        beta_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
# next we test different sigma^2 values#
sigma2_sample = c(0.1, 1, 10) #
sigma2_fit = matrix(0, length(sigma2_sample), length(t_sample))#
#
n = 100#
#
for(i in 1:length(sigma2_sample)){#
    for(j in 1:length(t_sample)){#
        t = t_sample[j]#
        slopes = runif(2)#
#
        xmat = cbind(rep(1, n), runif(n, -t, t))#
#
        EY = xmat %*% slopes#
#
        not_covered = NULL#
        for (k in 1:nrep) {#
            # The outcome data.#
            Y = xmat %*% slopes + rnorm(n, sd=sqrt(sigma2_sample[i]))#
#
            S = scheffe_band(Y, xmat)#
#
            not_covered[k] = sum((EY > S[,2]) | (EY < S[,1])) > 0#
        }#
        sigma2_fit[i,j] = sum(not_covered) / nrep#
    }#
}#
#
ggplot() + geom_point(aes(x=t_sample, y=n_fit[1,]), color="red") + geom_point(aes(x=t_sample, y=n_fit[2,]), color="blue") + geom_point(aes(x=t_sample, y=n_fit[3,]), color="green") + xlab("t") + ylab("Missing Prob")#
ggsave("sample_size_2.jpg")#
#
ggplot() + geom_point(aes(x=t_sample, y=beta_fit[1,]), color="red") + geom_point(aes(x=t_sample, y=beta_fit[2,]), color="blue") + geom_point(aes(x=t_sample, y=beta_fit[3,]), color="green") + xlab("t") + ylab("Missing Prob")#
ggsave("beta_2.jpg")#
#
ggplot() + geom_point(aes(x=t_sample, y=sigma2_fit[1,]), color="red") + geom_point(aes(x=t_sample, y=sigma2_fit[2,]), color="blue") + geom_point(aes(x=t_sample, y=sigma2_fit[3,]), color="green") + xlab("t") + ylab("Missing Prob")#
ggsave("sigma2_2.jpg")
p = 1#
n = 1000#
iter = 1000#
#
p_samples = seq(1, 50, 2)#
p_R2_var = rep(0, length(p_samples))#
p_R2_mu = rep(0, length(p_samples))#
p_R2_var_stab = rep(0, length(p_samples))#
p_R2_mu_stab = rep(0, length(p_samples))#
for(i in 1:length(p_samples)){#
    p = p_samples[i]#
    beta = runif(p)#
    beta = (beta - min(beta)) / max(beta)#
    R2_vec = rep(0, iter)    #
#
    for(j in 1:iter){#
        X = matrix(runif(n * p, 0, 10), ncol=p)#
        Y = X %*% beta + rnorm(n)#
        R2_vec[j] = summary(lm(Y ~ X))$r.squared#
    }#
    stab_R2 = 1 / 2 * log((1 + sqrt(R2_vec)) / (1 - sqrt(R2_vec)))#
    p_R2_var[i] = var(R2_vec)#
    p_R2_mu[i] = mean(R2_vec)#
    p_R2_var_stab[i] = var(stab_R2)#
    p_R2_mu_stab[i] = mean(stab_R2)#
}#
#
p = 1#
sd_samples = 1:50 #
sd_R2_var = rep(0, length(sd_samples))#
sd_R2_mu = rep(0, length(sd_samples))#
sd_R2_var_stab = rep(0, length(sd_samples))#
sd_R2_mu_stab = rep(0, length(sd_samples))#
beta = 1 #
for(i in 1:length(sd_samples)){#
    sd = sd_samples[i]   #
    R2_vec = rep(0, iter)    #
#
    for(j in 1:iter){#
        X = matrix(runif(n * p, -10, 10), ncol=p)#
        Y = X %*% beta + rnorm(n, sd=sd)#
        R2_vec[j] = summary(lm(Y ~ X))$r.squared#
    }#
    stab_R2 = 1 / 2 * log((1 + sqrt(R2_vec)) / (1 - sqrt(R2_vec)))#
    sd_R2_var[i] = var(R2_vec)#
    sd_R2_mu[i] = mean(R2_vec)#
    sd_R2_var_stab[i] = var(stab_R2)#
    sd_R2_mu_stab[i] = mean(stab_R2)#
}#
#
p = 1#
n_samples = seq(10, 1000, 10) #
n_R2_var = rep(0, length(n_samples))#
n_R2_mu = rep(0, length(n_samples))#
n_R2_var_stab = rep(0, length(n_samples))#
n_R2_mu_stab = rep(0, length(n_samples))#
beta = 1 #
for(i in 1:length(n_samples)){#
    n = n_samples[i]   #
    R2_vec = rep(0, iter)    #
#
    for(j in 1:iter){#
        X = matrix(runif(n * p, -10, 10), ncol=p)#
        Y = X %*% beta + rnorm(n)#
        R2_vec[j] = summary(lm(Y ~ X))$r.squared#
    }#
    stab_R2 = 1 / 2 * log((1 + sqrt(R2_vec)) / (1 - sqrt(R2_vec)))#
    n_R2_var[i] = var(R2_vec)#
    n_R2_mu[i] = mean(R2_vec)#
    n_R2_var_stab[i] = var(stab_R2)#
    n_R2_mu_stab[i] = mean(stab_R2)#
}
plot(n_R2_var)
plot(n_R2_var_stab)
plot(sd_R2_var_stab)
plot(sd_R2_var)
plot(p_R2_var)
plot(p_R2_var_stab)
ggplot() + geom_line(aes(x=n_samples, y=n_R2_var)) + geom_line(aes(x=n_samples, y=n_R2_var_stab))
library(ggplot2)#
#
p = 1#
n = 1000#
iter = 1000#
#
p_samples = 1:50 #
p_R2_var = rep(0, length(p_samples))#
p_R2_mu = rep(0, length(p_samples))#
p_R2_var_stab = rep(0, length(p_samples))#
p_R2_mu_stab = rep(0, length(p_samples))#
for(i in 1:length(p_samples)){#
    p = p_samples[i]#
    beta = runif(p)#
    beta = (beta - min(beta)) / max(beta)#
    R2_vec = rep(0, iter)    #
#
    for(j in 1:iter){#
        X = matrix(runif(n * p, 0, 10), ncol=p)#
        Y = X %*% beta + rnorm(n)#
        R2_vec[j] = summary(lm(Y ~ X))$r.squared#
    }#
    stab_R2 = 1 / 2 * log((1 + sqrt(R2_vec)) / (1 - sqrt(R2_vec)))#
    p_R2_var[i] = var(R2_vec)#
    p_R2_mu[i] = mean(R2_vec)#
    p_R2_var_stab[i] = var(stab_R2)#
    p_R2_mu_stab[i] = mean(stab_R2)#
}#
#
p = 1#
sd_samples = 1:50 #
sd_R2_var = rep(0, length(sd_samples))#
sd_R2_mu = rep(0, length(sd_samples))#
sd_R2_var_stab = rep(0, length(sd_samples))#
sd_R2_mu_stab = rep(0, length(sd_samples))#
beta = 1 #
for(i in 1:length(sd_samples)){#
    sd = sd_samples[i]   #
    R2_vec = rep(0, iter)    #
#
    for(j in 1:iter){#
        X = matrix(runif(n * p, -10, 10), ncol=p)#
        Y = X %*% beta + rnorm(n, sd=sd)#
        R2_vec[j] = summary(lm(Y ~ X))$r.squared#
    }#
    stab_R2 = 1 / 2 * log((1 + sqrt(R2_vec)) / (1 - sqrt(R2_vec)))#
    sd_R2_var[i] = var(R2_vec)#
    sd_R2_mu[i] = mean(R2_vec)#
    sd_R2_var_stab[i] = var(stab_R2)#
    sd_R2_mu_stab[i] = mean(stab_R2)#
}#
#
p = 1#
n_samples = seq(10, 1000, 10) #
n_R2_var = rep(0, length(n_samples))#
n_R2_mu = rep(0, length(n_samples))#
n_R2_var_stab = rep(0, length(n_samples))#
n_R2_mu_stab = rep(0, length(n_samples))#
beta = 1 #
for(i in 1:length(n_samples)){#
    n = n_samples[i]   #
    R2_vec = rep(0, iter)    #
#
    for(j in 1:iter){#
        X = matrix(runif(n * p, -10, 10), ncol=p)#
        Y = X %*% beta + rnorm(n)#
        R2_vec[j] = summary(lm(Y ~ X))$r.squared#
    }#
    stab_R2 = 1 / 2 * log((1 + sqrt(R2_vec)) / (1 - sqrt(R2_vec)))#
    n_R2_var[i] = var(R2_vec)#
    n_R2_mu[i] = mean(R2_vec)#
    n_R2_var_stab[i] = var(stab_R2)#
    n_R2_mu_stab[i] = mean(stab_R2)#
}#
#
ggplot() + geom_line(aes(x=n_samples, y=n_R2_var)) + geom_line(aes(x=n_samples, y=n_R2_var_stab), color="red") + xlab("Sample Size") + ylab("R2 Variance")#
ggsave("sample_size_5.jpg")#
#
ggplot() + geom_line(aes(x=sd_samples, y=sd_R2_var)) + geom_line(aes(x=sd_samples, y=sd_R2_var_stab), color="red") + xlab("Standard Deviation") + ylab("R2 Variance")#
ggsave("sd_5.jpg")#
#
ggplot() + geom_line(aes(x=p_samples, y=p_R2_var)) + geom_line(aes(x=p_samples, y=p_R2_var_stab), color="red") + xlab("Variable Count") + ylab("R2 Variance")#
ggsave("p_5.jpg")
test = rnorm(1000)
plot(test)
ggplot() + geom_line(aes(x=1:1000, y=test))
ggsave("stable.jpg")
ggplot() + geom_line(aes(x=1:1000, y=test)) + xlab("Time")
ggsave("stable.jpg")
test = sin(0:1000)
plot(test)
test1 = rnorm(500, sd=2)
test2 = rnorm(500, sd=5)
test = c(test1, test2)
ggplot() + geom_line(aes(x=1:1000, y=test)) + xlab("Time")
ggsave("change_variation.jpg")
test = 1:1000
test = rnorm(test, sd=10)
plot(test)
test = 1:1000
test
plot(test)
x <- rep(0, 1000)
n <- 1000
for(i in 2:n){#
  x[i] <- x[i - 1] + sample(step, 1)#
}
step
for(i in 2:n){#
  x[i] <- x[i - 1] + rnorm(10)#
}
warnings()
x <- rep(0, 1000)
for(i in 2:n){#
  x[i] <- x[i - 1] + rnorm(sd=10)#
}
x <- rep(0, 1000)
for(i in 2:n){#
  x[i] <- x[i - 1] + rnorm(1, sd=10)#
}
plot(x)
test = x
ggplot() + geom_line(aes(x=1:1000, y=test)) + xlab("Time")
ggsave("trend.jpg")
x = sin(seq(0, 100, pi/2))
plot(x)
x = sin(seq(0, 2*pi, 0.01))
plot(x)
test = rnorm(x, sd=100)
plot(test)
test = rnorm(x, sd=1)
plot(test)
test
length(test)
length(x)
plot(x)
plot(x^2)
test = rnorm((2*x)^2, sd=1)
plot(test)
plot((2 * x)^@)
plot((2 * x)^2)
x = (2 * x)^2
test = x + rnorm(length(x), sd=2)
plot(test)
test = x + rnorm(length(x), sd=1.5)
plot(test)
test = x + rnorm(length(x), sd=1.2)
plot(test)
test = x + rnorm(length(x), sd=1)
plot(test)
ggplot() + geom_line(aes(x=1:1000, y=test)) + xlab("Time")
ggplot() + geom_line(aes(x=1:length(test), y=test)) + xlab("Time")
ggsave("seasonal.jpg")
ggplot() + geom_line(aes(x=n_samples, y=n_R2_var), color="red") + geom_line(aes(x=n_samples, y=n_R2_var_stab)) + xlab("Sample Size") + ylab("R2 Variance")
ggsave("sample_size_5.jpg")
install.packages("splines")
library(splines)
library(foreign)#
library(ggplot2)#
#
data = read.xport("BPX_F.XPT")#
demo = read.xport("DEMO_F.XPT")#
merged = merge(data, demo, by="SEQN")#
#
men = merged[merged$RIAGENDR == 1,]#
#
men2 = men[!is.na(men$BPXSY1),]#
men2 = men2[(men2$BPXSY1 != 0),]#
oldmen = men2[(men2$RIDAGEYR > 60 & men2$RIDAGEYR < 70),]#
#
real_mn = mean(oldmen$BPXSY1)#
#
oldmen_hr = density(oldmen$BPXSY1)$x#
oldmen_rt = density(oldmen$BPXSY1)$y#
#
b = (140 - 25) / (150 - 125)#
a = 25 - b * 125#
#
prob = (oldmen_hr * b + a) / 10000#
prob = prob + abs(min(prob)) + 0.0001#
#
oldmen_rt_n = oldmen_rt * prob#
#
samp = sample(oldmen_hr, 10000, replace=T, prob=oldmen_rt_n)#
#
ndeath_mn = mean(samp)
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
nseq <- seq(100, 1000, 100)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 1000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
for(p in pseq){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha#
    X <- U %*% beta#
}
X
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
nseq <- seq(100, 1000, 100)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 1000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
for(p in pseq){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
}
fit <- lm(Y ~ X)
summary(fit)
library(glmnet)#
#
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 10000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
MSElasso <- c()#
MSEridge <- c()#
MSEenet <- c()#
#
for(p in pseq){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
#
    sub <- sample(n, floor(n * 0.9))#
    testY <- Y[-sub]#
    trainY <- Y[sub]#
    testX <- X[-sub,]#
    trainX <- X[sub,]#
#
    lassof <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    ridgef <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    enetf <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    MSElasso <- c(MSElasso, mean((testY - predict(testX, lassof))^2)#
    MSEridge <- c(MSEridge, mean((testY - predict(testX, ridgef))^2)#
    MSEenet <- c(MSEenet, mean((testY - predict(testX, enetf))^2)#
}
library(glmnet)#
#
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 10000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
MSElasso <- c()#
MSEridge <- c()#
MSEenet <- c()#
#
for(p in pseq){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
#
    sub <- sample(n, floor(n * 0.9))#
    testY <- Y[-sub]#
    trainY <- Y[sub]#
    testX <- X[-sub,]#
    trainX <- X[sub,]#
#
    lassof <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    ridgef <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    enetf <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    MSElasso <- c(MSElasso, mean((testY - predict(testX, lassof))^2))#
    MSEridge <- c(MSEridge, mean((testY - predict(testX, ridgef))^2))#
    MSEenet <- c(MSEenet, mean((testY - predict(testX, enetf))^2))#
}
install.packages("glmnet")
library(glmnet)
library(glmnet)#
#
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 10000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
MSElasso <- c()#
MSEridge <- c()#
MSEenet <- c()#
#
for(p in pseq){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
#
    sub <- sample(n, floor(n * 0.9))#
    testY <- Y[-sub]#
    trainY <- Y[sub]#
    testX <- X[-sub,]#
    trainX <- X[sub,]#
#
    lassof <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    ridgef <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    enetf <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    MSElasso <- c(MSElasso, mean((testY - predict(testX, lassof))^2))#
    MSEridge <- c(MSEridge, mean((testY - predict(testX, ridgef))^2))#
    MSEenet <- c(MSEenet, mean((testY - predict(testX, enetf))^2))#
}
library(glmnet)#
#
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 10000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
MSElasso <- c()#
MSEridge <- c()#
MSEenet <- c()#
#
for(p in pseq){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
#
    sub <- sample(n, floor(n * 0.9))#
    testY <- Y[-sub]#
    trainY <- Y[sub]#
    testX <- X[-sub,]#
    trainX <- X[sub,]#
#
    lassof <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    ridgef <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    enetf <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    MSElasso <- c(MSElasso, mean((testY - predict(lassof, testX))^2))#
    MSEridge <- c(MSEridge, mean((testY - predict(ridgef, testX))^2))#
    MSEenet <- c(MSEenet, mean((testY - predict(enetf, testX))^2))#
}
library(glmnet)#
#
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 10000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
MSElasso <- c()#
MSEridge <- c()#
MSEenet <- c()#
#
pln <- length(p)#
i <- 1#
#
for(p in pseq){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
#
    sub <- sample(n, floor(n * 0.9))#
    testY <- Y[-sub]#
    trainY <- Y[sub]#
    testX <- X[-sub,]#
    trainX <- X[sub,]#
#
    lassof <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    ridgef <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    enetf <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    MSElasso <- c(MSElasso, mean((testY - predict(lassof, testX))^2))#
    MSEridge <- c(MSEridge, mean((testY - predict(ridgef, testX))^2))#
    MSEenet <- c(MSEenet, mean((testY - predict(enetf, testX))^2))#
    i <- i + 1#
    print(paste(i, pln))    #
#
}
library(glmnet)#
#
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 10000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
MSElasso <- c()#
MSEridge <- c()#
MSEenet <- c()#
#
pln <- length(pseq)#
i <- 1#
#
for(p in pseq){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
#
    sub <- sample(n, floor(n * 0.9))#
    testY <- Y[-sub]#
    trainY <- Y[sub]#
    testX <- X[-sub,]#
    trainX <- X[sub,]#
#
    lassof <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    ridgef <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    enetf <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    MSElasso <- c(MSElasso, mean((testY - predict(lassof, testX))^2))#
    MSEridge <- c(MSEridge, mean((testY - predict(ridgef, testX))^2))#
    MSEenet <- c(MSEenet, mean((testY - predict(enetf, testX))^2))#
    i <- i + 1#
    print(paste(i, pln))    #
#
}
plot(MSEenet)
plot(MSElasso)
library(glmnet)#
#
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 1000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
MSElasso <- Null#
MSEridge <- Null#
MSEenet <- Null#
#
pln <- length(pseq)#
j <- 1#
samples <- 25#
#
for(p in pseq){#
    templasso <- c()#
    tempridge <- c()#
    tempenet <- c()#
    for(i in 1:samples){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
#
    sub <- sample(n, floor(n * 0.9))#
    testY <- Y[-sub]#
    trainY <- Y[sub]#
    testX <- X[-sub,]#
    trainX <- X[sub,]#
#
    lassof <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    ridgef <- cv.glmnet(trainX, trainY, alpha=0)$glmnet.fit#
    enetf <- cv.glmnet(trainX, trainY, alpha=0.5)$glmnet.fit#
    templasso <- c(templasso, mean((testY - predict(lassof, testX))^2))#
    tempridge <- c(tempridge, mean((testY - predict(ridgef, testX))^2))#
    tempenet <- c(tempenet, mean((testY - predict(enetf, testX))^2))#
    print(paste(j, pln))    #
    j <- j + 1#
    }#
    MSElasso <- cbind(MSElasso, templasso)#
    MSEridge <- cbind(MSEridge, tempridge)#
    MSEenet <- cbind(MSEenet, tempenet)#
}
library(glmnet)#
#
pseq <- seq(100, 1000, 100)#
kseq <- seq(5, 100, 5)#
bcorrseq <- seq(0.0, 0.9, 0.05)#
Xnoiseseq <- seq(2.5, 50, 2.5)#
Ynoiseseq <- seq(2.5, 50, 2.5)#
#
n <- 1000#
k <- 5#
p <- 100#
Xnoise <- 2.5#
Ynoise <- 2.5#
bcorr <- 0.1#
#
MSElasso <- Null#
MSEridge <- Null#
MSEenet <- Null#
#
pln <- length(pseq)#
j <- 1#
samples <- 25#
#
for(p in pseq){#
    templasso <- c()#
    tempridge <- c()#
    tempenet <- c()#
    for(i in 1:samples){#
    U <- matrix(rnorm((n * k)), n, k)#
    beta <- matrix(sample(c(0, 1), (p * k), replace=TRUE, prob=c(1-bcorr, bcorr)), k, p)#
    alpha <- rnorm(k)#
    Y <- U %*% alpha + rnorm(n, 0, Ynoise)#
    X <- U %*% beta + rnorm(n, 0, Xnoise)#
#
    sub <- sample(n, floor(n * 0.9))#
    testY <- Y[-sub]#
    trainY <- Y[sub]#
    testX <- X[-sub,]#
    trainX <- X[sub,]#
#
    lassof <- cv.glmnet(trainX, trainY, alpha=1)$glmnet.fit#
    ridgef <- cv.glmnet(trainX, trainY, alpha=0)$glmnet.fit#
    enetf <- cv.glmnet(trainX, trainY, alpha=0.5)$glmnet.fit#
    templasso <- c(templasso, mean((testY - predict(lassof, testX))^2))#
    tempridge <- c(tempridge, mean((testY - predict(ridgef, testX))^2))#
    tempenet <- c(tempenet, mean((testY - predict(enetf, testX))^2))#
    j <- j + 1#
    }#
    print(paste(j, pln))#
    MSElasso <- cbind(MSElasso, templasso)#
    MSEridge <- cbind(MSEridge, tempridge)#
    MSEenet <- cbind(MSEenet, tempenet)#
}
dim(MSEenet)
test <- apply(MSEenet, 1, mean)
test
test <- apply(MSEenet, 2, mean)
plot(Test)
plot(test)
test <- apply(MSElasso, 2, mean)
plot(test)
test <- apply(MSEridge, 2, mean)
plot(test)
test <- apply(MSEridge, 2, sd)
plot(test)
test <- apply(MSElasso, 2, sd)
plot(test)
test <- apply(MSElasso, 2, quantile(x, 0.95))
plot(test)
test <- apply(MSElasso, 2, mean)
plot(test)
test
mean(MSElasso)
mean(MSEridge)
mean(MSEenet)
test
test <- apply(MSEridge, 2, mean)
test
library(ggplot2)
ggplot() + geom_line(aes(x=pseq, y=apply(MSElasso, 2, mean))) + geom_line(aes(x=pseq, y=apply(MSEridge, 2, mean)), color="red") + geom_line(aes(x=pseq, y=apply(MSEenet, 2, mean)), color="green")
length(pseq)
length(apply(MSEenet, 2, mean))
ggplot() + geom_line(aes(x=pseq, y=apply(MSElasso, 2, mean)[2:11])) + geom_line(aes(x=pseq, y=apply(MSEridge, 2, mean)[2:11]), color="red") + geom_line(aes(x=pseq, y=apply(MSEenet, 2, mean)[2:11]), color="green")
MSEenet
ggplot() + geom_line(aes(x=pseq, y=apply(MSElasso, 2, mean)[2:11])) + geom_line(aes(x=pseq, y=apply(MSEridge, 2, mean)[2:11]), color="red") + geom_line(aes(x=pseq, y=apply(MSEenet, 2, mean)[2:11]), color="green")
test <- prcomp(X)
test
dim(test)
names(test)
test$sdev
plot(test$sdev)
plot(test$sdev[1:10])
test <- prcomp(trainX)
pred <- predict(test, testX)
pred
dim(pred)
pred <- predict(test, testX)
pred <- predict(test[1:5], testX)
test
names(test)
test$rotation
dim(test$rotation)
ggplot() + geom_line(aes(x=pseq, y=apply(MSElasso, 2, mean)[2:11])) + geom_line(aes(x=pseq, y=apply(MSEridge, 2, mean)[2:11]), color="red") + geom_line(aes(x=pseq, y=apply(MSEenet, 2, mean)[2:11]), color="green")
dim(X)
names(test)
test$scale
test$x
dim(test$x)
pred <- predict(test, testX)
test <- prcomp(trainX, scores=TRUE)
test$scores
names(test)
test <- princomp(trainX, scores=TRUE)
test <- princomp(data=trainX, scores=TRUE)
test <- princomp(trainX, scores=TRUE)
test <- prcomp(trainX, scores=TRUE)
test
names(test)
test$sdev
library(ggplot2)
test <- rnorm(100, 1:100, (1:100)/10)
test
plot(test)
fit1 <- lm(test ~ 1:100)
ind <- 1:100
fit1 <- lm(test ~ ind)
fit1$residuals
plot(fit1$residuals)
fit2 <- lm(fit1$residuals ~ ind)
fit2
summary(fit2)
source("http://kingaa.github.io/sbied/prep/packages.R", echo=TRUE)
source("http://kingaa.github.io/sbied/prep/pompTest.R", echo=TRUE)
Z = seq(-3, 3, 0.01)
test = pnorm(Z)
plot(test)
plot(Z, test)
plot(Z, test, type="l")
plot(Z, test, type="l", xlab="Hello")
plot(Z, test, type="l", xlab="Z")
plot(Z, test, type="l", xlab="Z", ylab="Power")
c1 <- qnorm(0.05)
c1
power <- pnorm(qnorm(0.05), Z) + 1 - pnorm(qnorm(0.95), Z)
power
plot(power)
plot(Z, power, type="l", xlab="Z", ylab="Power")
library(ggplot2)
ggplot() + geomline(aes(x=Z, y=power))
ggplot() + geom_line(aes(x=Z, y=power))
ggplot() + geom_line(aes(x=Z, y=power)) + xlab("Z") + ylab("Power")
ggsave("9b.pdf")
power = pnorm(Z)
ggplot() + geom_line(aes(x=Z, y=power)) + xlab("Z") + ylab("Power")
ggsave("9a.pdf")
getwd()
power <- pnorm(qnorm(0.05, 0, 0.00001), Z) + 1 - pnorm(qnorm(0.95, 0, 0.00001), Z)
ggplot() + geom_line(aes(x=Z, y=power)) + xlab("Z") + ylab("Power")
power <- pnorm(qnorm(0.05, 0, 100), Z) + 1 - pnorm(qnorm(0.95, 0, 100), Z)
ggplot() + geom_line(aes(x=Z, y=power)) + xlab("Z") + ylab("Power")
power <- pnorm(qnorm(0.05, 0, 0.0001), Z) + 1 - pnorm(qnorm(0.95, 0, 0.0001), Z)
ggplot() + geom_line(aes(x=Z, y=power)) + xlab("Z") + ylab("Power")
ggplot() + geom_line(aes(x=Z, y=power * 10)) + xlab("Z") + ylab("Power")
ggplot() + geom_line(aes(x=Z, y=scaled(power * 10))) + xlab("Z") + ylab("Power")
ggplot() + geom_line(aes(x=Z, y=power)) + xlab("Z") + ylab("Power")
install.packages("tseries")
library(tseries)
library(zoo)
## downloads historic prices for all constituents of SP500#
library(zoo)#
library(tseries)                        #
#
## read in list of constituents, with company name in first column and#
## ticker symbol in second column#
spComp <- read.csv("raw_data/sp500_constituents.csv" ) #
#
## specify time period#
dateStart <- "1995-01-01"               #
dateEnd <- "2013-05-01"#
#
## extract symbols and number of iterations#
symbols <- spComp[, 2]#
nAss <- length(symbols)#
#
## download data on first stock as zoo object#
z <- get.hist.quote(instrument = symbols[1], start = dateStart,#
                    end = dateEnd, quote = "AdjClose",#
                    retclass = "zoo", quiet = T)#
#
## use ticker symbol as column name #
dimnames(z)[[2]] <- as.character(symbols[1])#
#
## download remaining assets in for loop#
for (i in 2:nAss) {#
   ## display progress by showing the current iteration step#
   cat("Downloading ", i, " out of ", nAss , "\n")#
#
   result <- try(x <- get.hist.quote(instrument = symbols[i],#
                                     start = dateStart,#
                                     end = dateEnd, quote = "AdjClose",#
                                     retclass = "zoo", quiet = T))#
   if(class(result) == "try-error") {#
      next#
   }#
   else {#
      dimnames(x)[[2]] <- as.character(symbols[i])#
#
      ## merge with already downloaded data to get assets on same dates #
      z <- merge(z, x)                      #
#
   }#
}#
#
## save data#
write.zoo(z, file = "data/all_sp500_price_data.csv", index.name = "time")
rand(10)
rnum(10)
import.package("Rcpp")
load("Rcpp")
load.package("Rcpp")
library("Rcpp")
Rcpp.package.skeleton("changepoints")
getwd()
load("Rcpp")
load.package("Rcpp")
import.package("Rcpp")
library(Rcpp)
setwd("~/Documents/git_projects/changepoints")
compileAttributes()
getwd()
setwd('src')
compileAttributes()
setwd("..")
compileAttributes()
compileAttributes()
library(RcppAramdillo)
library(RcppArmadillo)
compileAttributes()
compileAttributes()
compileAttributes()
